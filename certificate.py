"""
This script will extract and store the information of a x509 certificate
contained in the log files generated by the certificate collector script.


Module Overview:
    1.  The main process opens the log file, creates a thread-safe queue, and
        spawns a child process.

        1.1.    The child process will continually do a blocking read from the
                thread-safe queue to obtain a buffer filled with certificates
                that the main process read from the log file.

        1.2.    The child process will extract the data from the x509
                certificate and start the transactions that will populate the
                database.

        1.3.    Once the buffer is depleted the child process will commit the
                pending transactions and then continue to attempt to read from
                the thread-safe queue.

    2.  The main process reads from the log file ONE byte at a time. Once the
        known sperator is discovered, the entire block read from the file is
        decoded and placed into a buffer.

    3.  Once the maximum buffer size is reached, the buffer is placed into the
        thread-safe queue. The main process does step 2 until there are no more
        Bytes to read from the file.

    4.  The main process will cleanup both the database connection as well as
        the process pool.

NOTE:
    The fingerprint is set off of the public key and not the x509 certificate
    like what is standard. In order to change this to the standard version
    the code below can be used on the x509 string:
    >>> hashlib.sha256(
            binascii.a2b_base64(
                "MIIDkzCCAvdWMw ... 3F1knWeieXliPgg=="
            )
        ).hexdigest()

"""

# Certificate conversion DER -> PEM
import ssl

# Conversion - Compatibility with the SSL library
import base64

# Parallel execution, process coordination, and PID information
import multiprocessing

# Database connections
import sqlite3

# Collecting data from shodan db files
import json
import gzip

# Extracting the SHA256 fingerprint of the public key
import binascii
import hashlib

# Iterating over file system directories
import os

# Cryptographic - Certificate information extraction
from OpenSSL.crypto                                 import load_certificate, FILETYPE_PEM
from cryptography.hazmat.primitives                 import serialization
from cryptography.hazmat.primitives.asymmetric.rsa  import RSAPublicNumbers
from cryptography.hazmat.primitives.asymmetric.dsa  import DSAPublicNumbers
from cryptography.hazmat.primitives.asymmetric.ec   import EllipticCurvePublicNumbers
from cryptography.hazmat.backends                   import default_backend

# Waiting and recording durations
from time                                           import sleep, time


# Sets the amount of forked processes that take the string form of the x509
# certificate and converts it into compatible SQL Insert queries for the
# database writer to consume and commit to the database.
CONVERSION_PROCESS_POOL_SIZE    =   4

# Amount of certificates to place in the thread-safe queue at once, this avoids
# the main thread constantly blocking the queue while reading the file from
# disk.
CERTIFICATE_BUFFER_SIZE         =   100_000

# Amount of time to block from a multiprocess queue before raising an exception
# indicating a timeout. This exception is expected to be handled by the caller
QUEUE_TIMEOUT                   =   10

# Ensures this process does not over-extend and consume all available system
# memory by queing the entire content of the certificate log, it is important to
# note that the actual memory usage is also influenced by the process pool size
# as each process can have one certificate buffer dequeued in memory as well as
# the full buffer queue size. See the docstring of this script for more
# information.
MAX_BUFFER_QUEUE_SIZE           =   5

# The directory to scan for all the collected certificates generated during the
# internet scan.
CERTIFICATE_DIRECTORY           =   "collected/scan_data/"

# Connect to the certificate database to write certificates
conn = sqlite3.connect("databases/tls.db")



class UnknownPrimitiveType(Exception):
    """ When the method to encrypt the certificate is not known. """
    pass


class CertificateData:
    """
    Ensures the collected data is standardized and compatible with the database
    structure.
    """

    # Every certificate must overwrite and contain these parameters
    public_numbers  =   None
    ipv4_address    =   None

    @property
    def public_key(self) -> str:
        """ Extracted public key from the peer handshake """
        pass

    @property
    def key_size(self) -> int:
        """ Size of the public key in bytes """
        pass

    @property
    def encryption(self) -> str:
        """ Type of encryption used during the generation of the public key """
        pass

    @property
    def fingerprint(self) -> str:
        """ Get the Hex Digest fingerprint of the public key """
        public_key  =   self.public_key.replace(
                                "-----BEGIN PUBLIC KEY-----", ""
                        ).replace(
                                "-----END PUBLIC KEY-----", ""
                        )

        return hashlib.sha256(binascii.a2b_base64(public_key)).hexdigest()

    def get_x509_info_query(self) -> str:
        """ Generation of x509 INSERT query to the SQLLite3 database """
        return None

    def get_public_key_query(self) -> str:
        """
        Generate SQL query to store the public key.
        """
        return  (
                    "INSERT INTO publicKeys("
                        "ipv4_address, fingerprint, public_key, "
                        "encryption, bits"
                    ") VALUES (\"{}\", \"{}\", \"{}\", \"{}\", \"{}\");"
                ).format(
                    self.ipv4_address,
                    self.fingerprint,
                    self.public_key,
                    self.encryption,
                    self.key_size
                )

    def get_public_number_query(self) -> str:
        """
        Generate SQL query to store the numbers used to generate the key.

        Raises:
            UnknownPrimitiveType: When the method to encrypt the public key is
                not RSA, DSA, or EC.

        """
        if isinstance(self.public_numbers, RSAPublicNumbers):
            query   =   (
                            "INSERT INTO rsaNumbers(ipv4_address, n, e) "
                            "VALUES (\"{}\", \"{}\", \"{}\");"
                        ).format(
                            self.ipv4_address,
                            "{:x}".format(self.public_numbers.n),
                            "{:x}".format(self.public_numbers.e)
                        )

        elif isinstance(self.public_numbers, EllipticCurvePublicNumbers):
            query   =   (
                            "INSERT INTO ecNumbers(ipv4_address, curve, x, y) "
                            "VALUES (\"{}\", \"{}\", \"{}\", \"{}\");"
                        ).format(
                            self.ipv4_address,
                            self.public_numbers.curve.name,
                            self.public_numbers.x,
                            self.public_numbers.y
                        )

        elif isinstance(self.public_numbers, DSAPublicNumbers):
            query   =   (
                            "INSERT INTO dsaNumbers(ipv4_address, y, p, q, g) "
                            "VALUES (\"{}\", \"{}\", \"{}\", \"{}\", \"{}\");"
                        ).format(
                            self.ipv4_address,
                            self.public_numbers.y,
                            self.public_numbers.parameter_numbers.p,
                            self.public_numbers.parameter_numbers.q,
                            self.public_numbers.parameter_numbers.g
                        )

        else: self.__raise_unknown_primitive_type__()

        return query

    def __raise_unknown_primitive_type__(self):
        """
        Raises an exception filled with the information about the public numbers
        that were used to create the public key.

        Raises:
            UnknownPrimitiveType: On call.

        """
        raise UnknownPrimitiveType(
            "IPv4: {}, Numbers (Type): {}, Numbers (Dir): {}".format(
                self.ipv4_address,
                type(self.public_numbers),
                dir(self.public_numbers)
            )
        )


class SSHKey(CertificateData):
    """
    Extraction and storage of SSH key information.
    """

    def __init__(self,
            ssh_key: str="",
            key_type: str="",
            ipv4_address: str="",
            public_key=None
        ) -> 'SSHKey':
        """
        Extract information from an SSH public key.

        Args:
            ssh_key (str): The captured SSH public key as a string.
            key_type (str): The encryption type used to create the public key.
            ipv4_address (str): The ipv4 address of the remote network device
                that held the public key.

        """
        self.ssh_key            =   ssh_key
        self.key_type           =   key_type
        self.ipv4_address       =   ipv4_address
        self.ssh_public_key     =   public_key
        self.public_numbers     =   self.ssh_public_key.public_numbers()

    @classmethod
    def from_string(cls,
            ssh_key: str="",
            key_type: str="",
            ipv4_address: str=""
        ) -> 'SSHKey':
        """
        Create a SSH Key object from the public key string obtained from the
        remote network device.

        Args:
            ssh_key (str): The captured SSH public key as a string.
            key_type (str): The encryption type used to create the public key.
            ipv4_address (str): The ipv4 address of the remote network device
                that held the public key.

        """
        if (not ssh_key.startswith(key_type)):
            ssh_key = "{} {}".format(key_type, ssh_key)

        ssh_key     =   ssh_key.replace("\n", "")
        public_key  =   serialization.load_ssh_public_key(
                                bytes(ssh_key, 'utf-8'),
                                backend = default_backend()
                        )

        return cls(ssh_key, key_type, ipv4_address, public_key)

    @classmethod
    def from_pem_public_key(cls,
            pem_data: str="",
            ipv4_address: str=""
        ) -> 'SSHKey':
        """
        Create a SSH Public Key object from a PEM certificate containing a
        public key identifier.

        Args:
            pem_data (str): The public key data of the pem file.
            ipv4_address (str): Attach an IPv4 address to the key in this object

        """
        if ((not isinstance(pem_data, str)) or
            (not pem_data.startswith("-----BEGIN PUBLIC KEY-----"))
        ):
            raise TypeError("Data must be a PEM public Key")

        pk = serialization.load_pem_public_key( pem_data.encode('ascii') )

        return cls(ipv4_address=ipv4_address, public_key=pk)

    @property
    def key_size(self) -> int:
        """
        Return the size, in bits, of the public key
        """
        return self.ssh_public_key.key_size

    @property
    def public_key(self) -> str:
        """
        Return the public key obtained from the remote network device.
        """
        return self.ssh_key

    @property
    def encryption(self) -> str:
        """
        Return the encryption type used to create the public key.
        """
        return self.key_type



class Certificate(CertificateData):
    """
    Extraction and storage of x509 certificate information.
    """

    def __init__(self, cert: str=None, ipv4_address: str=None) -> 'Certificate':
        """
        Create an x509 certificate from a PEM.

        Args:
            cert (str): PEM to create a certificate from.
            ipv4_address (str): The ipv4 address of the remote network device
                that held the x509 certificate.

        """
        self.ipv4_address       =   ipv4_address
        self.x509_certificate   =   cert
        self.x509               =   load_certificate(FILETYPE_PEM, cert)
        self.cryptography_key   =   self.x509.get_pubkey().to_cryptography_key()
        self.public_numbers     =   self.cryptography_key.public_numbers()


    def get_x509_info_query(self) -> str:
        """
        Generate SQL query to store the x509 certificate information.

        NOTE: `notBefore` and `notAfter` are stored in format "%Y%m%d%H%M%SZ"

        """
        # Get the issuer string and slice away identification bytes
        issuer      =   self.x509.get_issuer().__str__()
        issuer      =   issuer[
                                issuer.find("'") + 1
                                : issuer.rfind("'>")
                        ]

        # Get the subject string and slice away identification bytes
        subject     =   self.x509.get_subject().__str__()
        subject     =   subject[
                                subject.find("'") + 1
                                : subject.rfind("'>")
                        ]

        return  (
                    "INSERT INTO x509info("
                        "ipv4_address, fingerprint, issuer, subject, serial, "
                        "notBefore, notAfter"
                    ") VALUES ("
                        "\"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\""
                    ");"
                ).format(
                    self.ipv4_address,
                    self.fingerprint,
                    issuer.replace('"', "'"),
                    subject.replace('"', "'"),
                    self.x509.get_serial_number(),
                    self.x509.get_notBefore().decode(),
                    self.x509.get_notAfter().decode()
                )

    @property
    def key_size(self):
        """
        Return the size, in bits, of the public key
        """
        return self.x509.get_pubkey().bits()

    @property
    def public_key(self) -> str:
        """
        Get the public key extracted from the x509 certificate.
        """
        return self.cryptography_key.public_bytes(
                                serialization.Encoding.PEM,
                                serialization.PublicFormat.SubjectPublicKeyInfo
                ).decode()

    @property
    def encryption(self):
        """
        Determine the algorithm used during the generation of the cert.

        Raises:
            UnknownPrimitiveType: When the method to encrypt the public key is
                not RSA, DSA, or EC.

        """
        if (isinstance(self.public_numbers, RSAPublicNumbers)):
            return 'RSA'

        elif (isinstance(self.public_numbers, EllipticCurvePublicNumbers)):
            return 'EC'

        elif (isinstance(self.public_numbers, DSAPublicNumbers)):
            return 'DSA'

        self.__raise_unknown_primitive_type__()

    @classmethod
    def from_bytes(cls,
            certificate: bytearray=None,
            ipv4_address: str=""
        ) -> 'Certificate':
        """
        Get a certificate from the bytes representation of DER certificate.

        Args:
            certificate (bytes): DER certificate as base64 bytes.
            ipv4_address (str): The ipv4 address of the remote network device
                that held the x509 certificate.

        Returns:
            (Certificate) x509 certificate with extractable information.

        Raises:
            TypeError: If the passed certificate is not a bytearray.

        """
        # Ensure the certificate is represented in bytes
        if (not isinstance(certificate, (bytes, bytearray))):
            raise TypeError(f"Certificate passed as: {type(certificate)}")

        # Convert DER bytes to a PEM and return the Certificate
        return cls(ssl.DER_cert_to_PEM_cert(certificate), ipv4_address)

    @classmethod
    def from_string(cls,
            certificate: str=None,
            ipv4_address: str=""
        ) -> 'Certificate':
        """
        Get a certificate from the string representation of PEM certificate.

        Args:
            certificate (str): PEM certificate as base64 string.
            ipv4_address (str): The ipv4 address of the remote network device
                that held the x509 certificate.

        Returns:
            (Certificate) x509 certificate with extractable information.

        Raises:
            TypeError: If the passed certificate is not a string.

        """
        # Ensure the certificate is represented in string
        if (not isinstance(certificate, str)):
            raise TypeError(f"Certificate passed as: {type(certificate)}")

        # Certificate string is not in PEM form - Convert it
        if (not certificate.startswith("-----BEGIN CERTIFICATE-----")):
            return cls.from_bytes(base64.b64decode(certificate), ipv4_address)

        return cls(certificate, ipv4_address)


def read_certs_from_database(db_location: str="", current_count: int=0) -> int:
    """
    Collects x509 certificate from a database and extracts the information.

    Args:
        db_location (str): Specifies the location of the SQLite3 compatible
            database to use for extraction.

    """
    # Establish a connection and create a cursor to parse
    db      =   sqlite3.connect(db_location)
    cur     =   db.cursor()
    count   =   current_count

    # Collect everything in the database
    cur.execute("SELECT * FROM certs")

    # Iterate through the results in the query
    for cert in cur:
        try:
            # Increment data processed counter
            count += 1

            # Create a x509 certificate from the extracted data
            cert = Certificate.from_string(cert[1], cert[0])

            # conn.execute(cert.get_certificate_query())
            conn.execute(cert.get_public_key_query())
            conn.execute(cert.get_x509_info_query())
            conn.execute(cert.get_public_number_query())

        except sqlite3.IntegrityError:
            pass

        except Exception as e:
            print(str(e))

        # Ensure pending transaction list does not grow too large
        if (count % CERTIFICATE_BUFFER_SIZE) == 0:
            print("Processed: {:_}".format(count))
            conn.commit()

    # Clean up
    conn.commit()
    db.close()

    return count


def write_db_data(
        query_queue: multiprocessing.Queue=None,
        notify: multiprocessing.Event=None
    ) -> None:
    """
    Continuously attempts to write the data in the query queue into the
    established database connection until the main process notifies this process
    that the data has been read and certificate queue has been consumed.

    Args:
        query_queue (multiprocessing.Queue): A thread-safe queue containing the
            generated INSERT queries to write the x509 data to the database.
        notify (multiprocessing.Event): A thread-safe event which notifies this
            process that all queries have been generated and to exit after
            consuming the remaining data of the queue.

    """
    # Run forever
    while True:
        try:
            # Obtain a generated list of queries to write to the database
            queries = query_queue.get(True, timeout=QUEUE_TIMEOUT)

        except multiprocessing.queues.Empty:
            if (notify.is_set()):   break
            else:                   continue

        # Iterate through each query and write the data to the database
        for query in queries:
            if (query == None): continue
            try:    conn.execute(query)
            except: pass

        # Commit the pending transactions and write the data
        conn.commit()


def process_cert_data(
        raw_data_queue: multiprocessing.Queue=None,
        raw_data_event: multiprocessing.Event=None,
        query_queue: multiprocessing.Queue=None,
        is_shodan_data: bool=False
    ) -> None:
    """
    Converts and extracts information from a x509 compatible certificate.

    Args:
        raw_data_queue (multiprocessing.Queue): A thread-safe queue containing
            the raw data collected in the transport stream of a connection.
        raw_data_event (multiprocessing.Event): An event sent by the main
            process that notifies the processes of the pool that the certificate
            file has been completely scanned.
        query_queue (multiprocessing.Queue): A thread-safe queue that will be
            updated to contain the generated SQL INSERT queries to write the
            data of the x509 certificate to the database.
        is_shodan_data (bool): Identifies if the raw data was read from a file
            obtained from the shodan's resources.

    """
    # Run forever
    while True:

        # Collect the buffer containting certificates from the thread-safe queue
        try:
            raw_data_buffer = raw_data_queue.get(True, timeout=QUEUE_TIMEOUT)

        except multiprocessing.queues.Empty:
            if (raw_data_event.is_set()):   break
            else:                           continue

        # Buffer to hold all the generated queries from the certificates
        query_buffer = []

        # Iterate over each x509 certificate and fill the query buffer
        for raw_data in raw_data_buffer:
            try:
                if (is_shodan_data):
                    try:    processed_data = json.loads(raw_data)
                    except: continue

                    # Extract data from the loaded dictionary
                    ssh_data    =   processed_data.get('ssh', {})
                    public_key  =   ssh_data.get('key', None)
                    key_type    =   ssh_data.get('type', "").lower()

                    # port = processed_data.get("port", None)

                    # Ensure public key and encryption type
                    if (public_key == None or key_type == ""): continue

                    # Create a certificate from the compressed data
                    cert        =   SSHKey.from_string(
                                                public_key,
                                                key_type,
                                                processed_data.get('ip_str')
                                    )

                else:
                    # Break the data into IPv4 : Certificate pairing
                    parts       =   raw_data.decode().split('":"')

                    # Extract IP address and Certificate from the raw data
                    ipv4        =   parts[0][1:].split(":")[0]
                    cert        =   parts[1][:-3]

                    # Create a certificate from the parsed data
                    cert        =   Certificate.from_string(cert, ipv4)

                # Fill the query buffer with the extracted data inserts
                query_buffer.append(cert.get_public_key_query())
                query_buffer.append(cert.get_public_number_query())
                query_buffer.append(cert.get_x509_info_query())

            except Exception as e:
                if ("SSH supports only 1024 bit DSA keys" in str(e)): continue
                print("\n\nError: {}\nData: {}\n".format(e, raw_data))

        # Copy the query buffer to the thread-safe queue
        query_queue.put(query_buffer[:])


def display_status(
        cert_count: int=0,
        raw_data_q: multiprocessing.Queue=None,
        processed_data_q: multiprocessing.Queue=None,
        max_size: int=MAX_BUFFER_QUEUE_SIZE
    ) -> None:
    """
    Ensures buffer size threshold is maintained avoiding consumption of all
    system resources and displays the current queue states.

    Args:
        cert_count (int): Current queue count.
        raw_data_q (multiprocessing.Queue): Queue of raw data buffers ready for
            consumption by the process pool.
        processed_data_q (multiprocessing.Queue):  Queue of processed raw data
            ready for entry into the database.
        max_size (int): Maximum sum of the size of both queues. Note, that the
            amount of processes also has an effect. Each process may have a
            buffer dequed and this should be taken into consideration.

    """
    # Write current state to console
    def check_queue_resource_usage():
        print(
            "{:<15_} Buffered Raw Data: {:<6_} Buffered Processed Data: {:<6_}"
            .format( cert_count, raw_data_q.qsize(), processed_data_q.qsize() )
        )
        return ( (raw_data_q.qsize() + processed_data_q.qsize()) > max_size )

    # Ensure system resources are awaited
    while (check_queue_resource_usage()): sleep(5)


def read_certs_from_log(cert_file: str="", current_count: int=0) -> int:
    """
    Read certificates from log file.

    In an effort to reduce memory usage, the logs are read and processed one
    Byte at a time. Processed certificates are placed into a buffer, once the
    buffer is full it placed into a thread-safe queue for immediate processing.

    The main process is responsible for only reading from the file and
    identifying when a certificate has been fully read, so a process pool is
    used to evaluate the certificates and store the resulting data.

    Args:
        cert_file (str): Physical path location on disk where certificate log
            files are located.

    """
    # Initial defaults, assumptions, etc
    is_compressed           =   cert_file.endswith(".gz")
    is_shodan_data          =   cert_file.endswith((".gz", ".json"))
    cert_count              =   current_count
    raw_data_buffer         =   []

    # Coordination of raw data into the process pool for processing
    raw_data_queue          =   multiprocessing.Queue()
    raw_data_event          =   multiprocessing.Event()

    # Coordination of processed data into the database writer thread
    processed_data_queue    =   multiprocessing.Queue()
    processed_data_event    =   multiprocessing.Event()

    # Processes for parrallel execution
    data_processing_pool    =   multiprocessing.Pool(
                                        CONVERSION_PROCESS_POOL_SIZE,
                                        process_cert_data,
                                        (
                                            raw_data_queue,
                                            raw_data_event,
                                            processed_data_queue,
                                            is_shodan_data,
                                        )
                                )

    # Writes the data from the processed buffer to the database
    db_writer               =   multiprocessing.Process(
                                        target  =   write_db_data,
                                        args    =   (
                                                        processed_data_queue,
                                                        processed_data_event,
                                                    )
                                )

    # Open up the certificate log file to read the byte stream from it
    if (is_compressed): certs_file = gzip.open(cert_file, mode="rb")
    else:               certs_file = open(cert_file, "rb")

    # Start the database data writer process
    db_writer.start()

    # Run forever
    while True:
        # Read data from the certificate log and ensure its content
        raw_data = certs_file.readline()
        if (b'' == raw_data): break

        raw_data_buffer.append(raw_data)
        cert_count += 1

        # Copy the buffer to the queue once full
        if (len(raw_data_buffer) >= CERTIFICATE_BUFFER_SIZE):
            raw_data_queue.put(raw_data_buffer[:])
            raw_data_buffer = []
            display_status(cert_count, raw_data_queue, processed_data_queue)

    # Ensure any data in the buffer is written into the queue
    if (len(raw_data_buffer) > 0): raw_data_queue.put(raw_data_buffer[:])

    # Close certificate file and infrom the process pool to expect no new data
    print("Main Process: All raw data has been read from: ", cert_file)
    certs_file.close()
    raw_data_event.set()

    print("Main Process: Waiting for the process pool to consume the raw data.")
    display_status(cert_count, raw_data_queue, processed_data_queue, max_size=0)

    # Stop the processes of the process pool
    print("Main Process: Joining data processing process pool.")
    data_processing_pool.close()
    data_processing_pool.join()

    # Inform the database writer to expect no new data
    print("Main Process: Joining database writer process.")
    processed_data_event.set()
    db_writer.join()

    print("Main Process: Finished Processing data from: {}\n".format(cert_file))
    return cert_count


def create_db_from_log_dir(system_path:str=None) -> None:
    """
    Recursively reads the entire content of the provided system path and
    attempts to extract public key data from the contents.

    Args:
        system_path (str): Specifies the location of the logs created during
            the certificate scan.

    """
    # Ensure the system path points to a directory
    if (not os.path.isdir(system_path)):
        print("System path '", system_path, "' is not a directory")
        return

    count = 0

    # Walk through directories and sub directories checking each file
    for root, _, files in os.walk(system_path):

        # Iterate over each file
        for name in files:
            file_path = os.path.join(root, name)
            print("Main Process: Processing data from file:", file_path)
            start = time()

            # Only interested in the certificate logs
            if (".log" in file_path and "invalid" not in file_path):
                count = read_certs_from_log(file_path, count)

            # Special circumstance for the certificate database
            elif (".db" in file_path and "certificate" not in file_path):
                count = read_certs_from_database(file_path, count)

            else:
                print("Main Process: Skipping file: ", file_path)
                continue

            print("Main Process: Processing Duration:", time() - start)


if (__name__ == "__main__"):

    # Scan all the collected logs and extract the data in the certificates
    create_db_from_log_dir(CERTIFICATE_DIRECTORY)

